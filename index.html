<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sigma Chess RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #080808; 
            color: #e0e0e0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        h1, h2, h3, .serif-text { font-family: 'Cinzel', serif; }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .ui-layer {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        .menu-layer {
            position: absolute;
            inset: 0;
            background: rgba(8, 8, 8, 0.85);
            backdrop-filter: blur(20px);
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            overflow-y: auto;
        }
        .hidden-layer { display: none !important; }
        
        /* Elegant Effects */
        .accent-text { 
            color: var(--theme-glow); 
            text-shadow: 0 0 20px var(--theme-glow-dim);
        }
        
        .fatality-text { 
            font-size: clamp(3rem, 10vw, 6rem); 
            font-weight: 900; 
            color: var(--theme-glow);
            text-shadow: 0 0 30px var(--theme-glow-dim);
            letter-spacing: clamp(4px, 3vw, 15px);
            text-align: center;
            font-family: 'Cinzel', serif;
        }
        
        /* Evaluation Bar */
        #eval-bar-container {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 60%;
            background-color: rgba(10, 10, 10, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            transition: all 0.3s ease;
        }
        #eval-fill {
            width: 100%;
            height: 50%;
            background-color: var(--theme-glow);
            transition: height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #eval-text-w, #eval-text-b {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 9px;
            font-weight: 600;
            color: rgba(255,255,255,0.5);
            z-index: 2;
            padding: 4px 0;
            font-family: 'Inter', sans-serif;
        }
        #eval-text-b { top: 0; }
        #eval-text-w { bottom: 0; color: #000; }

        .luxury-panel {
            background: rgba(15, 15, 15, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 6px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .btn-luxury {
            background: rgba(20, 20, 20, 0.5);
            border: 1px solid var(--theme-glow-dim);
            color: var(--theme-text);
            padding: 14px 28px;
            font-size: clamp(0.85rem, 2vw, 1rem);
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            width: 100%;
            border-radius: 3px;
        }
        .btn-luxury:hover {
            background: var(--theme-glow);
            color: #050505;
            box-shadow: 0 0 20px var(--theme-glow-dim);
            border-color: var(--theme-glow);
        }
        
        @media (max-width: 640px) {
            .hud-container { flex-direction: column; gap: 0.5rem; align-items: center; }
            .luxury-panel { padding: 0.5rem 1rem; width: 100%; justify-content: center; }
            .desktop-only { display: none; }
            #eval-bar-container { left: 5px; width: 8px; height: 50%; }
        }
    </style>
</head>
<body style="--theme-glow: #d4af37; --theme-glow-dim: rgba(212,175,55,0.3); --theme-text: #d4af37;">

    <!-- MAIN MENU -->
    <div id="main-menu" class="menu-layer">
        <h1 class="text-4xl sm:text-6xl mb-2 text-center accent-text" style="letter-spacing: 8px;">ROYAL CHESS</h1>
        <h2 class="text-xs sm:text-sm text-gray-400 mb-12 uppercase tracking-[0.5em] text-center font-light">Grandmaster Edition</h2>
        
        <div class="space-y-4 flex flex-col w-11/12 max-w-xs">
            <button class="btn-luxury" onclick="MenuSystem.showSideSelection()">PLAY</button>
            <button class="btn-luxury" onclick="MenuSystem.showStatsMenu()" style="border-color:rgba(255,255,255,0.2); color:#ccc;">STATISTICS</button>
            <button class="btn-luxury" onclick="MenuSystem.showSettings()" style="border-color:rgba(255,255,255,0.2); color:#ccc;">SETTINGS</button>
        </div>
    </div>

    <!-- SIDE SELECTION -->
    <div id="side-menu" class="menu-layer hidden-layer">
        <h2 class="text-2xl sm:text-3xl mb-10 text-white text-center serif-text" style="letter-spacing: 4px;">CHOOSE FACTION</h2>
        <div class="flex flex-col sm:flex-row gap-5 w-11/12 max-w-md">
            <button class="btn-luxury" style="--theme-glow:#fff; --theme-text:#fff" onclick="GameCore.initGame('w')">WHITE</button>
            <button class="btn-luxury" style="--theme-glow:#888; --theme-text:#aaa" onclick="GameCore.initGame('b')">BLACK</button>
        </div>
        <button class="mt-8 text-gray-500 hover:text-white transition tracking-[0.3em] text-sm uppercase" onclick="GameCore.initGame('random')">Random Selection</button>
        <button class="mt-16 text-xs text-gray-500 hover:text-gray-300 tracking-[0.2em] uppercase" onclick="MenuSystem.showMainMenu()">Return</button>
    </div>

    <!-- SETTINGS -->
    <div id="settings-menu" class="menu-layer hidden-layer">
        <h2 class="text-2xl sm:text-3xl mb-10 text-white text-center serif-text" style="letter-spacing: 4px;">AESTHETICS</h2>
        <div class="space-y-5 flex flex-col w-11/12 max-w-xs">
            <button class="btn-luxury" style="--theme-glow:#d4af37; --theme-text:#d4af37" onclick="MenuSystem.setTheme('obsidian')">OBSIDIAN GOLD</button>
            <button class="btn-luxury" style="--theme-glow:#ffffff; --theme-text:#ffffff" onclick="MenuSystem.setTheme('ivory')">IVORY MARBLE</button>
        </div>
        <button class="mt-16 text-xs text-gray-500 hover:text-gray-300 tracking-[0.2em] uppercase" onclick="MenuSystem.showMainMenu()">Return</button>
    </div>

    <!-- STATISTICS -->
    <div id="stats-menu" class="menu-layer hidden-layer">
        <h2 class="text-2xl sm:text-3xl mb-8 text-center serif-text accent-text" style="letter-spacing: 4px;">TELEMETRY</h2>
        <div class="w-11/12 max-w-md luxury-panel p-8 text-left space-y-5 text-sm font-light tracking-wider">
            <div class="flex justify-between border-b border-gray-800 pb-3">
                <span class="text-gray-400">TOTAL TURNS</span> <span id="stat-turns" class="text-white font-medium">0</span>
            </div>
            <div class="flex justify-between border-b border-gray-800 pb-3">
                <span class="text-gray-400">ENEMIES CAPTURED</span> <span id="stat-kills" class="text-white font-medium">0</span>
            </div>
            <div class="flex justify-between border-b border-gray-800 pb-3">
                <span class="text-gray-400">CHECKS DELIVERED</span> <span id="stat-checks" class="text-white font-medium">0</span>
            </div>
            <div class="flex justify-between border-b border-gray-800 pb-3">
                <span class="text-gray-400">VICTORIES</span> <span id="stat-fatalities" class="text-white font-medium">0</span>
            </div>
        </div>
        <button class="mt-16 text-xs text-gray-500 hover:text-gray-300 tracking-[0.2em] uppercase" onclick="MenuSystem.showMainMenu()">Return</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="menu-layer hidden-layer bg-black/95">
        <h1 id="fatality-title" class="fatality-text mb-4">CHECKMATE</h1>
        <p id="winner-text" class="text-sm sm:text-base font-light text-gray-300 tracking-[0.4em] mb-16 text-center px-4 uppercase">White Triumphs</p>
        <div class="w-11/12 max-w-xs space-y-5">
            <button class="btn-luxury" onclick="GameCore.undo()" id="btn-undo-death" style="--theme-glow:#ccc;">REVERT TIME</button>
            <button class="btn-luxury" onclick="MenuSystem.showMainMenu()" style="--theme-glow:#d4af37;">MAIN MENU</button>
        </div>
    </div>

    <!-- GAME HUD -->
    <div id="game-hud" class="ui-layer top-0 left-0 w-full h-full pointer-events-none hidden-layer flex flex-col justify-between">
        
        <!-- Evaluation Bar -->
        <div id="eval-bar-container">
            <div id="eval-text-b" class="desktop-only"></div>
            <div id="eval-fill"></div>
            <div id="eval-text-w" class="desktop-only"></div>
        </div>

        <!-- TOP PANELS -->
        <div class="w-full p-4 sm:p-6 flex justify-between items-start pointer-events-none hud-container pl-12 sm:pl-20">
            <div class="luxury-panel px-5 sm:px-6 py-3 sm:py-4 pointer-events-auto flex items-center gap-4 w-full sm:w-auto">
                <div id="player-icon" class="w-8 h-8 sm:w-10 sm:h-10 rounded-full flex items-center justify-center border text-lg bg-black font-serif">♟</div>
                <div class="flex-1">
                    <h1 class="text-xs sm:text-sm font-semibold tracking-[0.2em] text-white uppercase" id="player-name">Player</h1>
                    <p class="text-[9px] sm:text-[10px] text-gray-500 tracking-widest uppercase mt-1" id="status-player">Your Turn</p>
                </div>
            </div>
            
            <div class="luxury-panel px-5 sm:px-6 py-3 sm:py-4 pointer-events-auto flex items-center gap-4 flex-row-reverse text-right w-full sm:w-auto mt-3 sm:mt-0">
                <div id="enemy-icon" class="w-8 h-8 sm:w-10 sm:h-10 rounded-full flex items-center justify-center border text-lg bg-black font-serif">♙</div>
                <div class="flex-1">
                    <h1 class="text-xs sm:text-sm font-semibold tracking-[0.2em] text-white uppercase" id="enemy-name">Grandmaster AI</h1>
                    <p class="text-[9px] sm:text-[10px] text-gray-500 tracking-widest uppercase mt-1" id="status-ai">Waiting</p>
                </div>
            </div>
        </div>
        
        <!-- Center Check Warning -->
        <div id="check-warning" class="absolute top-1/4 left-1/2 transform -translate-x-1/2 accent-text font-serif text-xl sm:text-2xl tracking-[0.3em] animate-pulse hidden-layer bg-black/60 px-8 py-3 rounded-sm border border-white/10 backdrop-blur-md pointer-events-none uppercase">
            Check
        </div>

        <!-- BOTTOM CONTROLS & MINI STATS -->
        <div class="w-full p-4 sm:p-6 flex justify-between items-end pointer-events-none pl-12 sm:pl-20">
            <div class="luxury-panel px-4 py-3 pointer-events-auto text-[10px] sm:text-xs font-light text-gray-400 desktop-only flex gap-6 tracking-widest uppercase">
                <span>Captures: <span id="mini-kills" class="text-white">0</span></span>
                <span>Moves: <span id="mini-turns" class="text-white">0</span></span>
            </div>

            <!-- UNDO / REDO CONTROLS -->
            <div class="flex gap-3 sm:gap-4 pointer-events-auto w-full sm:w-auto justify-end">
                <button id="btn-undo" class="btn-luxury text-[10px] sm:text-xs py-2 px-4 sm:px-6 opacity-30 pointer-events-none" onclick="GameCore.undo()">Undo</button>
                <button id="btn-redo" class="btn-luxury text-[10px] sm:text-xs py-2 px-4 sm:px-6 opacity-30 pointer-events-none" onclick="GameCore.redo()">Redo</button>
            </div>
        </div>
    </div>

    <!-- Cinematic Bars -->
    <div id="cinematic-bar-top" class="ui-layer top-0 left-0 w-full h-16 sm:h-24 bg-[#050505] transition-transform duration-300 -translate-y-full border-b border-white/5"></div>
    <div id="cinematic-bar-bottom" class="ui-layer bottom-0 left-0 w-full h-16 sm:h-24 bg-[#050505] transition-transform duration-300 translate-y-full border-t border-white/5"></div>

    <canvas id="gameCanvas"></canvas>

    <script>
        /**
         * =====================================================================
         * SIGMA CHESS RPG V4 - GRANDMASTER EDITION (Target Elo: ~1500)
         * Architecture: S3 MIT Level - Decoupled Logic & Visualization
         * Features: Minimax Alpha-Beta Pruning, PST Evaluation, FIDE Rules,
         * Eval Bar, Algebraic Notation, Threefold Repetition.
         * =====================================================================
         */

        const MathUtils = {
            lerp: (a, b, t) => a + (b - a) * t,
            random: (min, max) => Math.random() * (max - min) + min
        };

        const THEMES = {
            obsidian: {
                darkSquare: '#121212', lightSquare: '#262626',
                highlight: 'rgba(212, 175, 55, 0.3)', // Soft Gold
                playerText: '#d4af37', enemyText: '#aaaaaa',
                particlePlayer: '#d4af37', particleEnemy: '#dddddd',
                glow: '#d4af37', glowDim: 'rgba(212, 175, 55, 0.2)',
                coordColor: '#666'
            },
            ivory: {
                darkSquare: '#4a3b32', lightSquare: '#e8dcca',
                highlight: 'rgba(255, 255, 255, 0.4)',
                playerText: '#ffffff', enemyText: '#111111',
                particlePlayer: '#e8dcca', particleEnemy: '#4a3b32',
                glow: '#ffffff', glowDim: 'rgba(255, 255, 255, 0.3)',
                coordColor: '#887'
            }
        };

        const PIECE_VALUES = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000 };
        const PIECE_SYMBOLS = {
            'w': { 'p': '♙', 'n': '♘', 'b': '♗', 'r': '♖', 'q': '♕', 'k': '♔' },
            'b': { 'p': '♟', 'n': '♞', 'b': '♝', 'r': '♜', 'q': '♛', 'k': '♚' }
        };

        // --- SYNTHESIZER AUDIO ENGINE ---
        const AudioSys = {
            ctx: null,
            init() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                }
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            play(type, freq, duration, vol) {
                if (!this.ctx) return;
                try {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(this.ctx.currentTime + duration);
                } catch(e) {}
            },
            playUI() { this.play('sine', 800, 0.1, 0.1); },
            playSelect() { this.play('sine', 1200, 0.05, 0.1); },
            playMove() { this.play('triangle', 300, 0.1, 0.1); setTimeout(()=>this.play('triangle', 200, 0.1, 0.1), 50); },
            playCapture() { this.play('sawtooth', 150, 0.3, 0.2); this.play('square', 100, 0.3, 0.2); },
            playCheck() { this.play('square', 600, 0.2, 0.2); setTimeout(()=>this.play('square', 800, 0.4, 0.2), 100); },
            playFatality() { this.play('sawtooth', 60, 2.0, 0.5); this.play('square', 40, 2.0, 0.5); },
            playPromote() { this.play('sine', 400, 0.1, 0.1); setTimeout(()=>this.play('sine', 600, 0.1, 0.1), 100); setTimeout(()=>this.play('sine', 800, 0.3, 0.1), 200); }
        };

        window.addEventListener('click', () => AudioSys.init(), {once: true});
        window.addEventListener('touchstart', () => AudioSys.init(), {once: true});

        // --- GLOBAL STATE ---
        const State = {
            turn: 'w', playerColor: 'w', gameState: 'MENU',
            selectedSquare: null, validMoves: [],
            camera: { x: 0, y: 0, shakeX: 0, shakeY: 0, shakeIntensity: 0 },
            invertColors: false, particles: [], visualPieces: [],
            activeTheme: 'obsidian', isCheck: false,
            history: [], historyIndex: -1, currentEval: 0,
            stats: { turns: 0, kills: 0, checks: 0, fatalities: 0 }
        };

        // --- UI & MENUS ---
        const MenuSystem = {
            hideAll() { document.querySelectorAll('.menu-layer').forEach(el => el.classList.add('hidden-layer')); },
            showMainMenu() {
                AudioSys.playUI(); this.hideAll();
                document.getElementById('main-menu').classList.remove('hidden-layer');
                document.getElementById('game-hud').classList.add('hidden-layer');
                State.gameState = 'MENU';
                this.updateStatsUI();
            },
            showSideSelection() { AudioSys.playUI(); this.hideAll(); document.getElementById('side-menu').classList.remove('hidden-layer'); },
            showSettings() { AudioSys.playUI(); this.hideAll(); document.getElementById('settings-menu').classList.remove('hidden-layer'); },
            showStatsMenu() { AudioSys.playUI(); this.hideAll(); document.getElementById('stats-menu').classList.remove('hidden-layer'); },
            setTheme(themeName) {
                AudioSys.playUI(); State.activeTheme = themeName;
                const t = THEMES[themeName];
                document.body.style.setProperty('--theme-glow', t.glow);
                document.body.style.setProperty('--theme-glow-dim', t.glowDim);
                document.body.style.setProperty('--theme-text', t.glow);
            },
            updateStatsUI() {
                document.getElementById('stat-turns').innerText = State.stats.turns;
                document.getElementById('stat-kills').innerText = State.stats.kills;
                document.getElementById('stat-checks').innerText = State.stats.checks;
                document.getElementById('stat-fatalities').innerText = State.stats.fatalities;
                document.getElementById('mini-turns').innerText = State.stats.turns;
                document.getElementById('mini-kills').innerText = State.stats.kills;
            },
            updateEvalBar(score) {
                const fill = document.getElementById('eval-fill');
                const textW = document.getElementById('eval-text-w');
                const textB = document.getElementById('eval-text-b');
                
                let evalCp = score / 100;
                let winPercent = 50 + (evalCp * 5); 
                winPercent = Math.max(5, Math.min(95, winPercent)); 
                
                if (score > 10000) { winPercent = 100; evalCp = "M"; } 
                if (score < -10000) { winPercent = 0; evalCp = "-M"; } 

                fill.style.height = `${winPercent}%`;
                
                let displayTxt = (evalCp > 0 && evalCp !== "M") ? `+${evalCp.toFixed(1)}` : (evalCp !== "-M" && evalCp !== "M" ? evalCp.toFixed(1) : evalCp);
                if (score >= 0) {
                    textW.innerText = displayTxt; textB.innerText = "";
                } else {
                    textB.innerText = displayTxt; textW.innerText = "";
                }
            }
        };

        // --- 1. CHESS ENGINE (Fast Core Logic) ---
        class ChessEngine {
            constructor() {
                this.board = Array(8).fill(null).map(() => Array(8).fill(null));
                this.castling = { w: {k:true, q:true}, b: {k:true, q:true} };
                this.epSquare = null; 
                this.halfMoves = 0; 
                this.positionCounts = {}; 
            }

            cloneState() {
                return {
                    board: this.board.map(row => row.map(p => p ? {...p} : null)),
                    castling: JSON.parse(JSON.stringify(this.castling)),
                    epSquare: this.epSquare ? {...this.epSquare} : null,
                    halfMoves: this.halfMoves,
                    positionCounts: {...this.positionCounts}
                };
            }

            restoreState(state) {
                this.board = state.board.map(row => row.map(p => p ? {...p} : null));
                this.castling = JSON.parse(JSON.stringify(state.castling));
                this.epSquare = state.epSquare ? {...state.epSquare} : null;
                this.halfMoves = state.halfMoves;
                this.positionCounts = {...state.positionCounts};
            }

            setupBoard() {
                this.board = Array(8).fill(null).map(() => Array(8).fill(null));
                const order = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];
                for (let i = 0; i < 8; i++) {
                    this.board[0][i] = { color: 'b', type: order[i] };
                    this.board[1][i] = { color: 'b', type: 'p' };
                    this.board[6][i] = { color: 'w', type: 'p' };
                    this.board[7][i] = { color: 'w', type: order[i] };
                }
                this.castling = { w: {k:true, q:true}, b: {k:true, q:true} };
                this.epSquare = null; this.halfMoves = 0;
                this.positionCounts = {};
                this.recordPosition();
            }

            getPosKey() {
                let key = "";
                for(let y=0; y<8; y++) {
                    for(let x=0; x<8; x++) {
                        const p = this.board[y][x];
                        key += p ? p.color + p.type : "-";
                    }
                }
                key += `|${this.castling.w.k}${this.castling.w.q}${this.castling.b.k}${this.castling.b.q}`;
                key += `|${this.epSquare ? this.epSquare.x + ',' + this.epSquare.y : '-'}`;
                return key;
            }

            recordPosition() {
                const key = this.getPosKey();
                this.positionCounts[key] = (this.positionCounts[key] || 0) + 1;
            }
            
            removePositionRecord(key) {
                if (this.positionCounts[key]) this.positionCounts[key]--;
            }

            isThreefoldRepetition() {
                return Object.values(this.positionCounts).some(v => v >= 3);
            }

            getPiece(x, y) { return (x >= 0 && x <= 7 && y >= 0 && y <= 7) ? this.board[y][x] : null; }

            getPseudoMoves(x, y, colorOverwrite = null) {
                const piece = this.board[y][x];
                if (!piece) return [];
                const moves = [];
                const color = colorOverwrite || piece.color;
                const oppColor = color === 'w' ? 'b' : 'w';
                const dir = color === 'w' ? -1 : 1;

                const addIfValid = (nx, ny, canCapture = true, mustCapture = false) => {
                    if (nx < 0 || nx > 7 || ny < 0 || ny > 7) return false;
                    const target = this.board[ny][nx];
                    if (target) {
                        if (target.color !== color && canCapture) moves.push({ from: {x,y}, to: {x: nx, y: ny, target} });
                        return false;
                    } else if (!mustCapture) {
                        moves.push({ from: {x,y}, to: {x: nx, y: ny, target: null} });
                        return true;
                    }
                    return false;
                };
                const slide = (dx, dy) => { let nx = x + dx, ny = y + dy; while (addIfValid(nx, ny)) { nx += dx; ny += dy; } };

                switch (piece.type) {
                    case 'p':
                        if (addIfValid(x, y + dir, false, false)) {
                            if ((color === 'w' && y === 6) || (color === 'b' && y === 1)) addIfValid(x, y + dir * 2, false, false);
                        }
                        addIfValid(x - 1, y + dir, true, true);
                        addIfValid(x + 1, y + dir, true, true);
                        if (this.epSquare && this.epSquare.y === y + dir && Math.abs(this.epSquare.x - x) === 1) {
                            moves.push({ from: {x,y}, to: {x: this.epSquare.x, y: this.epSquare.y, target: {type:'p', color:oppColor}, isEP: true} });
                        }
                        break;
                    case 'n': [[-1,-2],[1,-2],[-2,-1],[2,-1],[-1,2],[1,2],[-2,1],[2,1]].forEach(([dx, dy]) => addIfValid(x+dx, y+dy)); break;
                    case 'b': [[-1,-1],[1,-1],[-1,1],[1,1]].forEach(([dx, dy]) => slide(dx, dy)); break;
                    case 'r': [[0,-1],[0,1],[-1,0],[1,0]].forEach(([dx, dy]) => slide(dx, dy)); break;
                    case 'q': [[-1,-1],[1,-1],[-1,1],[1,1],[0,-1],[0,1],[-1,0],[1,0]].forEach(([dx, dy]) => slide(dx, dy)); break;
                    case 'k':
                        [[-1,-1],[1,-1],[-1,1],[1,1],[0,-1],[0,1],[-1,0],[1,0]].forEach(([dx, dy]) => addIfValid(x+dx, y+dy));
                        if (this.castling[color].k && !this.board[y][5] && !this.board[y][6] && !this.isSquareAttacked(4, y, oppColor) && !this.isSquareAttacked(5, y, oppColor) && !this.isSquareAttacked(6, y, oppColor)) {
                            moves.push({ from:{x,y}, to:{x: 6, y: y, target: null, isCastle: true} });
                        }
                        if (this.castling[color].q && !this.board[y][1] && !this.board[y][2] && !this.board[y][3] && !this.isSquareAttacked(4, y, oppColor) && !this.isSquareAttacked(3, y, oppColor) && !this.isSquareAttacked(2, y, oppColor)) {
                            moves.push({ from:{x,y}, to:{x: 2, y: y, target: null, isCastle: true} });
                        }
                        break;
                }
                return moves;
            }

            isSquareAttacked(targetX, targetY, attackerColor) {
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const piece = this.board[y][x];
                        if (piece && piece.color === attackerColor) {
                            if (piece.type === 'p') {
                                const dir = attackerColor === 'w' ? -1 : 1;
                                if ((targetY === y + dir) && Math.abs(targetX - x) === 1) return true;
                            } else if (piece.type === 'k') {
                                if (Math.abs(targetX - x) <= 1 && Math.abs(targetY - y) <= 1) return true;
                            } else {
                                const moves = this.getPseudoMoves(x, y);
                                if (moves.some(m => m.to.x === targetX && m.to.y === targetY)) return true;
                            }
                        }
                    }
                }
                return false;
            }

            isInCheck(color) {
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const p = this.board[y][x];
                        if (p && p.type === 'k' && p.color === color) {
                            return this.isSquareAttacked(x, y, color === 'w' ? 'b' : 'w');
                        }
                    }
                }
                return false;
            }

            makeMoveFast(move) {
                const fromX = move.from.x, fromY = move.from.y;
                const toX = move.to.x, toY = move.to.y;
                const piece = this.board[fromY][fromX];
                const target = this.board[toY][toX];
                
                const revertData = {
                    pieceMoved: piece.type, target: target, epSquare: this.epSquare,
                    castling: JSON.parse(JSON.stringify(this.castling)), halfMoves: this.halfMoves,
                    isPromoted: false, isEP: move.to.isEP, isCastle: move.to.isCastle,
                    prevPosKey: this.getPosKey()
                };

                this.halfMoves = (piece.type === 'p' || target) ? 0 : this.halfMoves + 1;
                this.epSquare = null;

                if (move.to.isEP) this.board[fromY][toX] = null; 
                
                if (move.to.isCastle) {
                    if (toX > fromX) { this.board[fromY][5] = this.board[fromY][7]; this.board[fromY][7] = null; } 
                    else { this.board[fromY][3] = this.board[fromY][0]; this.board[fromY][0] = null; } 
                }

                this.board[toY][toX] = piece;
                this.board[fromY][fromX] = null;

                if (piece.type === 'k') { this.castling[piece.color].k = false; this.castling[piece.color].q = false; }
                if (piece.type === 'r') {
                    if (fromX === 0) this.castling[piece.color].q = false;
                    if (fromX === 7) this.castling[piece.color].k = false;
                }
                if (target && target.type === 'r') {
                    if (toX === 0) this.castling[target.color].q = false;
                    if (toX === 7) this.castling[target.color].k = false;
                }

                if (piece.type === 'p' && Math.abs(toY - fromY) === 2) this.epSquare = { x: fromX, y: (fromY + toY) / 2 };
                if (piece.type === 'p' && (toY === 0 || toY === 7)) {
                    piece.type = 'q'; revertData.isPromoted = true;
                }

                return revertData;
            }

            unmakeMoveFast(move, revertData) {
                const fromX = move.from.x, fromY = move.from.y;
                const toX = move.to.x, toY = move.to.y;
                const piece = this.board[toY][toX];

                if (revertData.isPromoted) piece.type = 'p';

                this.board[fromY][fromX] = piece;
                this.board[toY][toX] = revertData.target;

                if (revertData.isEP) {
                    this.board[toY][toX] = null;
                    this.board[fromY][toX] = { type: 'p', color: piece.color === 'w' ? 'b' : 'w' };
                }

                if (revertData.isCastle) {
                    if (toX > fromX) { this.board[fromY][7] = this.board[fromY][5]; this.board[fromY][5] = null; }
                    else { this.board[fromY][0] = this.board[fromY][3]; this.board[fromY][3] = null; }
                }

                this.epSquare = revertData.epSquare;
                this.castling = revertData.castling;
                this.halfMoves = revertData.halfMoves;
            }

            // Fungsi yang diperlukan untuk validasi pergerakan dari satu petak
            getLegalMoves(x, y) {
                const piece = this.getPiece(x, y);
                if (!piece) return [];
                const pseudoMoves = this.getPseudoMoves(x, y);
                const legalMoves = [];

                for (let move of pseudoMoves) {
                    const rev = this.makeMoveFast(move);
                    if (!this.isInCheck(piece.color)) {
                        legalMoves.push(move);
                    }
                    this.unmakeMoveFast(move, rev);
                }
                return legalMoves;
            }

            getAllLegalMoves(color) {
                let moves = [];
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const p = this.board[y][x];
                        if (p && p.color === color) {
                            const pseudoMoves = this.getPseudoMoves(x, y);
                            for (let m of pseudoMoves) {
                                const rev = this.makeMoveFast(m);
                                if (!this.isInCheck(color)) moves.push(m);
                                this.unmakeMoveFast(m, rev);
                            }
                        }
                    }
                }
                return moves;
            }
        }

        const Engine = new ChessEngine();

        // --- 2. AI ENGINE (Minimax + Alpha-Beta + PST) Target Elo 1500 ---
        const SigmaAI = {
            nodesEvaluated: 0,
            
            PST: {
                p: [
                    [0,  0,  0,  0,  0,  0,  0,  0],
                    [50, 50, 50, 50, 50, 50, 50, 50],
                    [10, 10, 20, 30, 30, 20, 10, 10],
                    [5,  5, 10, 25, 25, 10,  5,  5],
                    [0,  0,  0, 20, 20,  0,  0,  0],
                    [5, -5,-10,  0,  0,-10, -5,  5],
                    [5, 10, 10,-20,-20, 10, 10,  5],
                    [0,  0,  0,  0,  0,  0,  0,  0]
                ],
                n: [
                    [-50,-40,-30,-30,-30,-30,-40,-50],
                    [-40,-20,  0,  0,  0,  0,-20,-40],
                    [-30,  0, 10, 15, 15, 10,  0,-30],
                    [-30,  5, 15, 20, 20, 15,  5,-30],
                    [-30,  0, 15, 20, 20, 15,  0,-30],
                    [-30,  5, 10, 15, 15, 10,  5,-30],
                    [-40,-20,  0,  5,  5,  0,-20,-40],
                    [-50,-40,-30,-30,-30,-30,-40,-50]
                ],
                b: [
                    [-20,-10,-10,-10,-10,-10,-10,-20],
                    [-10,  0,  0,  0,  0,  0,  0,-10],
                    [-10,  0,  5, 10, 10,  5,  0,-10],
                    [-10,  5,  5, 10, 10,  5,  5,-10],
                    [-10,  0, 10, 10, 10, 10,  0,-10],
                    [-10, 10, 10, 10, 10, 10, 10,-10],
                    [-10,  5,  0,  0,  0,  0,  5,-10],
                    [-20,-10,-10,-10,-10,-10,-10,-20]
                ],
                r: [
                    [ 0,  0,  0,  0,  0,  0,  0,  0],
                    [ 5, 10, 10, 10, 10, 10, 10,  5],
                    [-5,  0,  0,  0,  0,  0,  0, -5],
                    [-5,  0,  0,  0,  0,  0,  0, -5],
                    [-5,  0,  0,  0,  0,  0,  0, -5],
                    [-5,  0,  0,  0,  0,  0,  0, -5],
                    [-5,  0,  0,  0,  0,  0,  0, -5],
                    [ 0,  0,  0,  5,  5,  0,  0,  0]
                ],
                q: [
                    [-20,-10,-10, -5, -5,-10,-10,-20],
                    [-10,  0,  0,  0,  0,  0,  0,-10],
                    [-10,  0,  5,  5,  5,  5,  0,-10],
                    [ -5,  0,  5,  5,  5,  5,  0, -5],
                    [  0,  0,  5,  5,  5,  5,  0, -5],
                    [-10,  5,  5,  5,  5,  5,  0,-10],
                    [-10,  0,  5,  0,  0,  0,  0,-10],
                    [-20,-10,-10, -5, -5,-10,-10,-20]
                ],
                k: [
                    [-30,-40,-40,-50,-50,-40,-40,-30],
                    [-30,-40,-40,-50,-50,-40,-40,-30],
                    [-30,-40,-40,-50,-50,-40,-40,-30],
                    [-30,-40,-40,-50,-50,-40,-40,-30],
                    [-20,-30,-30,-40,-40,-30,-30,-20],
                    [-10,-20,-20,-20,-20,-20,-20,-10],
                    [ 20, 20,  0,  0,  0,  0, 20, 20],
                    [ 20, 30, 10,  0,  0, 10, 30, 20]
                ]
            },

            evaluatePosition(engine) {
                let score = 0;
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const p = engine.board[y][x];
                        if (p) {
                            let pstVal = 0;
                            if (p.color === 'w') pstVal = this.PST[p.type][y][x];
                            else pstVal = this.PST[p.type][7-y][x];
                            
                            let val = PIECE_VALUES[p.type] + pstVal;
                            score += p.color === 'w' ? val : -val;
                        }
                    }
                }
                return score;
            },

            minimax(engine, depth, alpha, beta, isMaximizing, color) {
                this.nodesEvaluated++;
                if (depth === 0) return this.evaluatePosition(engine);

                const moves = engine.getAllLegalMoves(isMaximizing ? color : (color==='w'?'b':'w'));
                
                if (moves.length === 0) {
                    if (engine.isInCheck(isMaximizing ? color : (color==='w'?'b':'w'))) {
                        return isMaximizing ? -99999 + (10-depth) : 99999 - (10-depth); 
                    }
                    return 0; 
                }

                moves.sort((a,b) => {
                    let scoreA = a.to.target ? PIECE_VALUES[a.to.target.type] : 0;
                    if (a.to.isPromoted) scoreA += 900;
                    let scoreB = b.to.target ? PIECE_VALUES[b.to.target.type] : 0;
                    if (b.to.isPromoted) scoreB += 900;
                    return scoreB - scoreA;
                });

                if (isMaximizing) {
                    let maxEval = -Infinity;
                    for (let move of moves) {
                        const rev = engine.makeMoveFast(move);
                        const ev = this.minimax(engine, depth - 1, alpha, beta, false, color);
                        engine.unmakeMoveFast(move, rev);
                        maxEval = Math.max(maxEval, ev);
                        alpha = Math.max(alpha, ev);
                        if (beta <= alpha) break;
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (let move of moves) {
                        const rev = engine.makeMoveFast(move);
                        const ev = this.minimax(engine, depth - 1, alpha, beta, true, color);
                        engine.unmakeMoveFast(move, rev);
                        minEval = Math.min(minEval, ev);
                        beta = Math.min(beta, ev);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            },

            getBestMove(engine, depth, color) {
                this.nodesEvaluated = 0;
                let bestMove = null;
                let bestValue = color === 'w' ? -Infinity : Infinity;
                let alpha = -Infinity;
                let beta = Infinity;

                const moves = engine.getAllLegalMoves(color);
                
                moves.sort(() => Math.random() - 0.5);
                moves.sort((a,b) => (b.to.target ? 1000 : 0) - (a.to.target ? 1000 : 0));

                for (let move of moves) {
                    const rev = engine.makeMoveFast(move);
                    const boardVal = this.minimax(engine, depth - 1, alpha, beta, false, color);
                    engine.unmakeMoveFast(move, rev);

                    if (color === 'w') {
                        if (boardVal > bestValue) { bestValue = boardVal; bestMove = move; }
                        alpha = Math.max(alpha, boardVal);
                    } else {
                        if (boardVal < bestValue) { bestValue = boardVal; bestMove = move; }
                        beta = Math.min(beta, boardVal);
                    }
                }
                
                State.currentEval = bestValue;
                MenuSystem.updateEvalBar(bestValue); 
                
                return bestMove;
            }
        };

        // --- 3. RENDERER VISUAL & UI ---
        class VisualPiece {
            constructor(x, y, logicalPiece) {
                this.logicalX = x; this.logicalY = y;
                this.renderX = x; this.renderY = y;
                this.piece = logicalPiece;
                this.scale = 1; this.opacity = 1;
                this.isDead = false; this.isAttacking = false;
            }

            update() {
                if (this.isDead) {
                    this.scale = MathUtils.lerp(this.scale, 0, 0.15);
                    this.opacity = MathUtils.lerp(this.opacity, 0, 0.15);
                    return;
                }
                if (!this.isAttacking) {
                    this.renderX = MathUtils.lerp(this.renderX, this.logicalX, 0.25);
                    this.renderY = MathUtils.lerp(this.renderY, this.logicalY, 0.25);
                }
            }

            draw(ctx, cellSize, offsetX, offsetY) {
                if (this.opacity < 0.05) return;
                let visualX = State.playerColor === 'w' ? this.renderX : 7 - this.renderX;
                let visualY = State.playerColor === 'w' ? this.renderY : 7 - this.renderY;
                const px = offsetX + visualX * cellSize + cellSize / 2;
                const py = offsetY + visualY * cellSize + cellSize / 2;

                ctx.save(); ctx.translate(px, py); ctx.scale(this.scale, this.scale); ctx.globalAlpha = this.opacity;

                ctx.beginPath(); ctx.ellipse(0, cellSize*0.35, cellSize*0.25, cellSize*0.08, 0, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fill();

                ctx.font = `bold ${cellSize * 0.7}px Arial`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const isWhite = this.piece.color === 'w';
                const theme = THEMES[State.activeTheme];
                ctx.fillStyle = isWhite ? '#ffffff' : '#222222';
                ctx.shadowBlur = 15; ctx.shadowColor = isWhite ? theme.glow : '#ff0000';
                
                if (!isWhite) { ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 2; ctx.strokeText(PIECE_SYMBOLS[this.piece.color][this.piece.type], 0, 0); }
                ctx.fillText(PIECE_SYMBOLS[this.piece.color][this.piece.type], 0, 0);
                
                if (this.piece.isPromoted) {
                    ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 20;
                    ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 1; ctx.strokeText(PIECE_SYMBOLS[this.piece.color][this.piece.type], 0, 0);
                }
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color, isText = false, text = "") {
                this.x = x; this.y = y;
                this.vx = MathUtils.random(-20, 20); this.vy = MathUtils.random(-20, 20);
                this.life = 1.0; this.color = color;
                this.size = MathUtils.random(4, 12);
                this.isText = isText; this.text = text;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.vy += 0.8;
                this.life -= MathUtils.random(0.06, 0.1); 
                if(this.isText) { this.vy -= 1.5; this.life -= 0.02; }
            }
            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                if (this.isText) {
                    ctx.font = '900 clamp(20px, 4vw, 35px) "Courier New"';
                    ctx.fillStyle = this.color; ctx.textAlign = 'center';
                    ctx.shadowBlur = 15; ctx.shadowColor = this.color;
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
                    ctx.strokeText(this.text, this.x, this.y); ctx.fillText(this.text, this.x, this.y);
                } else {
                    ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }

        const Renderer = {
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d', { alpha: false }),
            cellSize: 0, offsetX: 0, offsetY: 0,

            resize() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * dpr; this.canvas.height = window.innerHeight * dpr;
                this.ctx.scale(dpr, dpr);
                const minDim = Math.min(window.innerWidth, window.innerHeight);
                this.cellSize = Math.floor((minDim * 0.90) / 8); 
                if (window.innerWidth > 640) this.cellSize = Math.floor((minDim * 0.75) / 8); 

                this.offsetX = (window.innerWidth - (this.cellSize * 8)) / 2;
                if (window.innerWidth > 640) this.offsetX += 20; 

                this.offsetY = window.innerHeight > window.innerWidth ? (window.innerHeight - this.cellSize*8)/2 + 40 : (window.innerHeight - this.cellSize*8)/2 + 20;
            },

            triggerScreenShake(intensity = 15) { State.camera.shakeIntensity = intensity; },

            createExplosion(logicalX, logicalY, color, textMsg, isFatality = false) {
                let vx = State.playerColor === 'w' ? logicalX : 7 - logicalX;
                let vy = State.playerColor === 'w' ? logicalY : 7 - logicalY;
                const px = this.offsetX + vx * this.cellSize + this.cellSize/2;
                const py = this.offsetY + vy * this.cellSize + this.cellSize/2;
                
                const count = isFatality ? 80 : 25;
                for(let i=0; i<count; i++) State.particles.push(new Particle(px, py, color));
                if (textMsg) State.particles.push(new Particle(px, py - 30, color, true, textMsg));
                this.triggerScreenShake(isFatality ? 30 : 15);
            },

            async executeMoveAnimation(visualPiece, moveObj) {
                State.gameState = 'ANIMATING';
                const toX = moveObj.to.x; const toY = moveObj.to.y;
                const isFatalityCheck = moveObj.to.target && moveObj.to.target.type === 'k';

                let rookVisual = null; let rookToX = 0;
                if (moveObj.to.isCastle) {
                    const rookX = toX > visualPiece.logicalX ? 7 : 0;
                    rookToX = toX > visualPiece.logicalX ? 5 : 3;
                    rookVisual = State.visualPieces.find(vp => vp.logicalX === rookX && vp.logicalY === visualPiece.logicalY);
                }

                let targetVisual = State.visualPieces.find(vp => vp.logicalX === toX && vp.logicalY === toY);
                let explodeY = toY;
                if (moveObj.to.isEP) {
                    targetVisual = State.visualPieces.find(vp => vp.logicalX === toX && vp.logicalY === visualPiece.logicalY);
                    explodeY = visualPiece.logicalY;
                }

                if (targetVisual) {
                    document.getElementById('cinematic-bar-top').style.transform = 'translateY(0)';
                    document.getElementById('cinematic-bar-bottom').style.transform = 'translateY(0)';
                    visualPiece.isAttacking = true;
                    
                    const dx = toX - visualPiece.logicalX; const dy = toY - visualPiece.logicalY;
                    const angle = Math.atan2(dy, dx);
                    visualPiece.renderX -= Math.cos(angle) * 1.5; visualPiece.renderY -= Math.sin(angle) * 1.5;
                    await new Promise(r => setTimeout(r, 250));

                    visualPiece.renderX = toX; visualPiece.renderY = toY;
                    await new Promise(r => setTimeout(r, 50));

                    const theme = THEMES[State.activeTheme];
                    const color = targetVisual.piece.color === 'w' ? theme.particlePlayer : theme.particleEnemy;
                    
                    if (isFatalityCheck) {
                        State.invertColors = true; AudioSys.playFatality(); State.stats.fatalities++;
                        this.createExplosion(toX, explodeY, theme.glow, "SKAKMAT", true);
                        visualPiece.scale = 2.0;
                        await new Promise(r => setTimeout(r, 150));
                        State.invertColors = false;
                        await new Promise(r => setTimeout(r, 400));
                    } else {
                        AudioSys.playCapture(); State.stats.kills++;
                        const dmgText = "CAPTURE";
                        this.createExplosion(toX, explodeY, color, dmgText);
                        visualPiece.scale = 1.4;
                    }
                    
                    targetVisual.isDead = true;
                    await new Promise(r => setTimeout(r, 200)); 
                    visualPiece.isAttacking = false; visualPiece.scale = 1;
                    document.getElementById('cinematic-bar-top').style.transform = 'translateY(-100%)';
                    document.getElementById('cinematic-bar-bottom').style.transform = 'translateY(100%)';
                } else {
                    AudioSys.playMove();
                    visualPiece.logicalX = toX; visualPiece.logicalY = toY;
                    await new Promise(r => setTimeout(r, 150));
                }

                if (rookVisual) rookVisual.logicalX = rookToX;

                Engine.makeMoveFast(moveObj);
                Engine.recordPosition();
                
                if (visualPiece.piece.type === 'p' && (toY === 0 || toY === 7)) {
                    AudioSys.playPromote();
                    this.createExplosion(toX, toY, '#ffff00', "PROMOTION!");
                }

                GameCore.syncVisualPieces();
                GameCore.nextTurn();
            }
        };

        // --- 4. GAME CONTROLLER ---
        const GameCore = {
            initGame(colorChoice) {
                AudioSys.playUI(); MenuSystem.hideAll(); document.getElementById('game-hud').classList.remove('hidden-layer');
                if (colorChoice === 'random') colorChoice = Math.random() > 0.5 ? 'w' : 'b';
                
                State.playerColor = colorChoice; State.turn = 'w'; State.gameState = 'IDLE';
                State.isCheck = false; State.history = []; State.historyIndex = -1;
                State.stats = { turns: 0, kills: 0, checks: 0, fatalities: 0 };
                
                const theme = THEMES[State.activeTheme];
                const pColorHex = State.playerColor === 'w' ? theme.glow : '#888';
                const eColorHex = State.playerColor === 'w' ? '#888' : theme.glow;
                document.getElementById('player-icon').innerText = State.playerColor === 'w' ? '♙' : '♟';
                document.getElementById('player-icon').style.borderColor = pColorHex; document.getElementById('player-icon').style.color = pColorHex;
                document.getElementById('enemy-icon').innerText = State.playerColor === 'w' ? '♟' : '♙';
                document.getElementById('enemy-icon').style.borderColor = eColorHex; document.getElementById('enemy-icon').style.color = eColorHex;

                Engine.setupBoard(); 
                this.syncVisualPieces(); 
                this.updateHUD(); 
                this.saveState();
                
                const initialEval = SigmaAI.evaluatePosition(Engine);
                MenuSystem.updateEvalBar(initialEval);

                if (State.playerColor === 'b') setTimeout(() => this.processAITurn(), 800);
            },

            saveState() {
                if (State.historyIndex < State.history.length - 1) State.history = State.history.slice(0, State.historyIndex + 1);
                State.history.push({
                    logicState: Engine.cloneState(),
                    turn: State.turn, isCheck: State.isCheck,
                    stats: {...State.stats}, evalVal: State.currentEval
                });
                State.historyIndex = State.history.length - 1;
                this.updateUndoRedoUI();
            },

            restoreState(historyState) {
                Engine.restoreState(historyState.logicState);
                State.turn = historyState.turn; State.isCheck = historyState.isCheck;
                State.stats = {...historyState.stats};
                State.gameState = 'IDLE'; State.selectedSquare = null; State.validMoves = [];
                State.currentEval = historyState.evalVal || 0;
                this.syncVisualPieces(); this.updateHUD(); this.updateUndoRedoUI();
                MenuSystem.updateStatsUI();
                MenuSystem.updateEvalBar(State.currentEval);
            },

            undo() {
                if (State.gameState === 'ANIMATING') return;
                AudioSys.playUI();
                let targetIndex = State.historyIndex - 1;
                while(targetIndex >= 0 && State.history[targetIndex].turn !== State.playerColor) targetIndex--;
                if (targetIndex >= 0) {
                    State.historyIndex = targetIndex;
                    document.getElementById('game-over-screen').classList.add('hidden-layer');
                    this.restoreState(State.history[State.historyIndex]);
                }
            },

            redo() {
                if (State.gameState === 'ANIMATING') return;
                AudioSys.playUI();
                let targetIndex = State.historyIndex + 1;
                while(targetIndex < State.history.length && State.history[targetIndex].turn !== State.playerColor) targetIndex++;
                if (targetIndex < State.history.length) {
                    State.historyIndex = targetIndex;
                    document.getElementById('game-over-screen').classList.add('hidden-layer');
                    this.restoreState(State.history[State.historyIndex]);
                }
            },

            updateUndoRedoUI() {
                const btnUndo = document.getElementById('btn-undo'); const btnRedo = document.getElementById('btn-redo');
                const btnUndoDeath = document.getElementById('btn-undo-death');
                let canUndo = false;
                for (let i = State.historyIndex - 1; i >= 0; i--) { if (State.history[i].turn === State.playerColor) { canUndo = true; break; } }
                btnUndo.style.opacity = canUndo ? "1" : "0.3"; btnUndo.style.pointerEvents = canUndo ? "auto" : "none";
                btnUndoDeath.style.display = canUndo ? "block" : "none";

                let canRedo = false;
                for (let i = State.historyIndex + 1; i < State.history.length; i++) { if (State.history[i].turn === State.playerColor) { canRedo = true; break; } }
                btnRedo.style.opacity = canRedo ? "1" : "0.3"; btnRedo.style.pointerEvents = canRedo ? "auto" : "none";
            },

            syncVisualPieces() {
                State.visualPieces = [];
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const piece = Engine.getPiece(x, y);
                        if (piece) State.visualPieces.push(new VisualPiece(x, y, piece));
                    }
                }
            },

            nextTurn() {
                if(State.turn === State.playerColor) State.stats.turns++;
                State.turn = State.turn === 'w' ? 'b' : 'w';
                State.selectedSquare = null; State.validMoves = [];
                
                State.isCheck = Engine.isInCheck(State.turn);
                if (State.isCheck) { AudioSys.playCheck(); State.stats.checks++; }
                MenuSystem.updateStatsUI();

                const allLegalMoves = Engine.getAllLegalMoves(State.turn);
                const isThreefold = Engine.isThreefoldRepetition();
                
                if (allLegalMoves.length === 0 || Engine.halfMoves >= 100 || isThreefold) {
                    State.gameState = 'GAME_OVER';
                    this.saveState(); 
                    this.triggerGameOver(State.isCheck, Engine.halfMoves >= 100 || isThreefold, isThreefold);
                    return;
                }

                State.gameState = 'IDLE';
                this.updateHUD(); this.saveState();

                if (State.turn !== State.playerColor) {
                    setTimeout(() => this.processAITurn(), 100);
                }
            },

            triggerGameOver(isCheckmate, isDrawRule, isThreefold) {
                const isPlayerWin = State.turn !== State.playerColor; 
                setTimeout(() => {
                    document.getElementById('game-over-screen').classList.remove('hidden-layer');
                    if (isCheckmate) {
                        document.getElementById('fatality-title').innerText = "SKAKMAT";
                        document.getElementById('winner-text').innerText = isPlayerWin ? "KEMENANGAN ANDA" : "KEMENANGAN AI";
                        document.getElementById('winner-text').style.color = isPlayerWin ? "var(--theme-glow)" : "#888";
                    } else {
                        document.getElementById('fatality-title').innerText = isThreefold ? "REPETISI" : (isDrawRule ? "ATURAN 50 LANGKAH" : "STALEMATE");
                        document.getElementById('winner-text').innerText = "SERI";
                        document.getElementById('winner-text').style.color = "#aaaaaa";
                    }
                }, 1000); 
            },

            updateHUD() {
                const statusP = document.getElementById('status-player'); const statusAI = document.getElementById('status-ai');
                const checkWarn = document.getElementById('check-warning');
                
                if (State.isCheck) checkWarn.classList.remove('hidden-layer');
                else checkWarn.classList.add('hidden-layer');

                if (State.turn === State.playerColor) {
                    statusP.innerText = "GILIRAN ANDA"; statusP.style.color = 'var(--theme-glow)';
                    statusAI.innerText = "MENUNGGU"; statusAI.style.color = 'gray';
                } else {
                    statusAI.innerText = "MENGANALISIS"; statusAI.style.color = '#fff';
                    statusP.innerText = "MENUNGGU"; statusP.style.color = 'gray';
                }
            },

            processAITurn() {
                if (State.gameState !== 'IDLE') return;
                
                const depth = 3; 
                
                setTimeout(() => {
                    const bestMove = SigmaAI.getBestMove(Engine, depth, State.turn);
                    if (bestMove) {
                        const visualPiece = State.visualPieces.find(vp => vp.logicalX === bestMove.from.x && vp.logicalY === bestMove.from.y);
                        visualPiece.piece.logicalX_old = bestMove.from.x; visualPiece.piece.logicalY_old = bestMove.from.y;
                        Renderer.executeMoveAnimation(visualPiece, bestMove);
                    }
                }, 50);
            }
        };

        // --- 5. INPUT HANDLING ---
        function getLogicalPos(e) {
            let cx = e.touches ? e.touches[0].clientX : e.clientX;
            let cy = e.touches ? e.touches[0].clientY : e.clientY;
            let visualX = Math.floor((cx - Renderer.offsetX) / Renderer.cellSize);
            let visualY = Math.floor((cy - Renderer.offsetY) / Renderer.cellSize);
            
            let logicalX = State.playerColor === 'w' ? visualX : 7 - visualX;
            let logicalY = State.playerColor === 'w' ? visualY : 7 - visualY;
            
            return {x: logicalX, y: logicalY};
        }

        Renderer.canvas.addEventListener('mousedown', handleInput);
        Renderer.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e); }, {passive: false});

        function handleInput(e) {
            if (State.gameState !== 'IDLE' || State.turn !== State.playerColor) return;

            const {x, y} = getLogicalPos(e);
            if (x < 0 || x > 7 || y < 0 || y > 7) { State.selectedSquare = null; State.validMoves = []; return; }

            const move = State.validMoves.find(m => m.to.x === x && m.to.y === y);
            if (move && State.selectedSquare) {
                const visualPiece = State.visualPieces.find(vp => vp.logicalX === State.selectedSquare.x && vp.logicalY === State.selectedSquare.y);
                visualPiece.piece.logicalX_old = State.selectedSquare.x; visualPiece.piece.logicalY_old = State.selectedSquare.y;
                Renderer.executeMoveAnimation(visualPiece, move);
                return;
            }

            const piece = Engine.getPiece(x, y);
            if (piece && piece.color === State.playerColor) {
                AudioSys.playSelect(); 
                State.selectedSquare = {x, y};
                State.validMoves = Engine.getLegalMoves(x, y); 
                Renderer.triggerScreenShake(2); 
            } else {
                State.selectedSquare = null; State.validMoves = [];
            }
        }

        // --- RENDER LOOP ---
        function renderLoop() {
            const ctx = Renderer.ctx; const cs = Renderer.cellSize; const theme = THEMES[State.activeTheme];

            if (State.camera.shakeIntensity > 0) {
                State.camera.shakeX = MathUtils.random(-State.camera.shakeIntensity, State.camera.shakeIntensity);
                State.camera.shakeY = MathUtils.random(-State.camera.shakeIntensity, State.camera.shakeIntensity);
                State.camera.shakeIntensity *= 0.85; 
                if (State.camera.shakeIntensity < 0.5) State.camera.shakeIntensity = 0;
            }

            ctx.fillStyle = theme.darkSquare; ctx.fillRect(0, 0, Renderer.canvas.width, Renderer.canvas.height);

            if (State.invertColors) {
                ctx.globalCompositeOperation = 'difference'; ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, Renderer.canvas.width, Renderer.canvas.height);
                ctx.globalCompositeOperation = 'source-over';
            }

            ctx.save(); ctx.translate(State.camera.shakeX, State.camera.shakeY);

            ctx.strokeStyle = theme.glowDim; ctx.lineWidth = 2;
            ctx.strokeRect(Renderer.offsetX, Renderer.offsetY, cs * 8, cs * 8);

            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const isLight = (x + y) % 2 === 0;
                    ctx.fillStyle = isLight ? theme.lightSquare : theme.darkSquare;
                    
                    let vx = State.playerColor === 'w' ? x : 7 - x;
                    let vy = State.playerColor === 'w' ? y : 7 - y;
                    
                    const px = Renderer.offsetX + vx * cs;
                    const py = Renderer.offsetY + vy * cs;
                    
                    ctx.fillRect(px, py, cs, cs);
                    
                    // Notasi Aljabar (Koordinat a-h, 1-8)
                    ctx.fillStyle = theme.coordColor;
                    ctx.font = `bold ${Math.max(10, cs * 0.15)}px Arial`;
                    ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                    if (vx === 0) { 
                        ctx.fillText(8 - y, px + 2, py + 2);
                    }
                    if (vy === 7) { 
                        ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                        ctx.fillText(String.fromCharCode(97 + x), px + cs - 2, py + cs - 2);
                    }
                    
                    if (State.selectedSquare && State.selectedSquare.x === x && State.selectedSquare.y === y) {
                        ctx.fillStyle = theme.highlight; ctx.fillRect(px, py, cs, cs);
                    }
                    
                    if (State.isCheck) {
                        const p = Engine.getPiece(x,y);
                        if (p && p.type === 'k' && p.color === State.turn) {
                            ctx.fillStyle = `rgba(255, 0, 0, ${0.4 + Math.sin(Date.now()/100)*0.3})`;
                            ctx.fillRect(px, py, cs, cs);
                        }
                    }
                }
            }

            State.validMoves.forEach(m => {
                let vx = State.playerColor === 'w' ? m.to.x : 7 - m.to.x;
                let vy = State.playerColor === 'w' ? m.to.y : 7 - m.to.y;
                const px = Renderer.offsetX + vx * cs; const py = Renderer.offsetY + vy * cs;
                
                if (m.to.target || m.to.isEP) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${0.3 + Math.sin(Date.now() / 150) * 0.2})`;
                    ctx.fillRect(px, py, cs, cs); ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2; ctx.strokeRect(px, py, cs, cs);
                } else {
                    ctx.fillStyle = theme.glowDim; ctx.beginPath(); ctx.arc(px + cs/2, py + cs/2, cs*0.15, 0, Math.PI*2); ctx.fill();
                }
            });

            State.visualPieces.sort((a, b) => {
                let yA = State.playerColor === 'w' ? a.renderY : 7 - a.renderY;
                let yB = State.playerColor === 'w' ? b.renderY : 7 - b.renderY;
                return yA - yB;
            });
            State.visualPieces.forEach(p => { p.update(); p.draw(ctx, cs, Renderer.offsetX, Renderer.offsetY); });

            if(State.particles.length > 200) State.particles.splice(0, State.particles.length - 200);
            State.particles = State.particles.filter(p => p.life > 0);
            State.particles.forEach(p => { p.update(); p.draw(ctx); });

            ctx.restore(); requestAnimationFrame(renderLoop);
        }

        window.addEventListener('resize', () => Renderer.resize());
        Renderer.resize(); requestAnimationFrame(renderLoop);

    </script>
</body>
</html>
